// 有多少种二叉树
// 输入n(1<n<13)，求n个结点的二叉树有多少种形态
// 时间限制：1000
// 内存限制：65536
// 输入
// 整数n
// 输出
// 答案
// 样例输入
// 3
// 样例输出
// 5

// 解题思路：
// 题目要求我们计算n个节点的二叉树的形态数。我们可以使用动态规划来解决。

// 我们可以将n个节点的二叉树划分为左子树和右子树两部分。对于i个节点的二叉树，我们可以将1个节点用作根节点，然后将其划分为左子树和右子树两部分，分别包含 i-1 和 0 个节点或者 i-2 和 1 个节点。这样，我们就可以将 i 个节点的二叉树的数量表示为其左子树和右子树的数量之积的和。

// 具体来说，我们可以使用一个一维数组 dp 来记录不同节点数的二叉树的数量，其中 dp[i] 表示 i 个节点的二叉树的数量。初始时，我们将 dp[0] 和 dp[1] 的值设置为 1。然后，我们可以使用一个循环来依次计算 dp[2] 到 dp[n] 的值。

// 对于每个 dp[i]，我们使用另外一个循环来遍历其左子树和右子树的所有可能节点数，然后将左子树的节点数与右子树的节点数相乘，累加到 dp[i] 中。最终，我们可以输出 dp[n] 即可。

// 在主函数中，我们首先读入节点数 n，然后使用一个一维数组 dp 来记录不同节点数的二叉树的数量。

// 接着，我们使用两层循环来计算 dp[2] 到 dp[n] 的值。在内层循环中，我们枚举左子树和右子树的节点数，然后将左子树的节点数与右子树的节点数相乘，累加到 dp[i] 中。

// 最后，我们输出 dp[n] 即可。


#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> dp(n+1, 0);  // 一维数组 dp，其中 dp[i] 表示 i 个节点的二叉树的数量
    dp[0] = 1;  // 初始化 dp[0] 和 dp[1]
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < i; j++) {  // 枚举左子树和右子树的节点数
            dp[i] += dp[j] * dp[i-j-1];  // 计算 i 个节点的二叉树数量
        }
    }

    cout << dp[n] << endl;  // 输出 n 个节点的二叉树数量

    return 0;
}
