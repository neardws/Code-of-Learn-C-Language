// Sequence
// 给定m个数字序列，每个序列包含n个非负整数。我们从每一个序列中选取一个数字组成一个新的序列，显然一共可以构造出n^m个新序列。接下来我们对每一个新的序列中的数字进行求和，一共会得到n^m个和，请找出最小的n个和
// 时间限制：3000
// 内存限制：65536
// 输入
// 输入的第一行是一个整数T，表示测试用例的数量，接下来是T个测试用例的输入 每个测试用例输入的第一行是两个正整数m（0 < m <= 100）和n(0 < n <= 2000)，然后有m行，每行有n个数，数字之间用空格分开，表示这m个序列 序列中的数字不会大于10000
// 输出
// 对每组测试用例，输出一行用空格隔开的数，表示最小的n个和
// 样例输入
// 1
// 2 3
// 1 2 3
// 2 2 3
// 样例输出
// 3 3 4


// 解题思路：
// 题目要求我们从 m 个序列中各选取一个数字组成一个新的序列，并对新序列中的数字进行求和，找出最小的 n 个和。我们可以将所有序列按照从小到大的顺序排序，然后依次计算这些序列的前缀和，然后利用归并排序的思想将这些前缀和排序，最后输出前 n 个数即可。

// 具体地，我们可以定义一个二维数组 nums 来存储 m 个序列中的数字。然后，我们可以先将每个序列按照从小到大的顺序排序，然后计算每个序列的前缀和，并将这些前缀和存储到一个一维数组 prefix_sums 中。接着，我们可以使用归并排序的思想将这些前缀和排序，并输出前 n 个数即可。

// 在主函数中，我们首先读入测试数据的组数 T。然后，对于每组测试数据，我们首先读入 m 和 n，然后读入 m 个序列中的数字，并将它们按照从小到大的顺序排序。接着，我们枚举新序列中的每一个数字，依次计算每个序列的前缀和，并将它们存储到一个一维数组 prefix_sums 中。然后，我们使用 sort 函数对所有前缀和进行排序，并将前 n 小的和存储到一个数组 ans 中。最后，我们使用 sort 函数对所有和进行排序，并输出前 n 小的和。

// 需要注意的是，如果 m < n，那么前 n 小的和就是所有和，因此在代码中我们使用 min(n, m) 来计算前 n 小的和。


#include <bits/stdc++.h>
using namespace std;

int nums[105][2005];  // 定义一个二维数组存储序列中的数字

int main() {
    int T;
    cin >> T;

    while (T--) {
        int m, n;
        cin >> m >> n;

        // 读入每个序列中的数字
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                cin >> nums[i][j];
            }
            sort(nums[i], nums[i] + n);  // 对序列中的数字进行排序
        }

        vector<int> prefix_sums(m);  // 定义一个数组存储每个序列的前缀和
        vector<int> ans;  // 定义一个数组存储前 n 小的和

        for (int i = 0; i < n; i++) {  // 枚举新序列中的每一个数字
            int sum = 0;
            for (int j = 0; j < m; j++) {  // 枚举选取的数字所在的序列
                sum += nums[j][i];  // 将这个序列中的数字加到总和中
                prefix_sums[j] = sum;  // 计算这个序列的前缀和
            }
            sort(prefix_sums.begin(), prefix_sums.end());  // 对所有前缀和进行排序
            for (int j = 0; j < n && j < m; j++) {
                ans.push_back(prefix_sums[j]);  // 将前 n 小的和存储到数组中
            }
        }

        sort(ans.begin(), ans.end());  // 对所有和进行排序
        for (int i = 0; i < n; i++) {
            cout << ans[i] << " ";  // 输出前 n 小的和
        }
        cout << endl;
    }

    return 0;
}
