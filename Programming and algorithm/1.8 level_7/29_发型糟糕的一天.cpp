// 发型糟糕的一天
// 农夫John 的N(1 ≤ N ≤ 80,000)只奶牛中，有一些也许正在经历发型糟糕的一天。
// 每只奶牛对自己乱糟糟的发型都有自知之明，农夫John想知道所有奶牛能看到其他奶牛头顶的数量之和。
// 任意奶牛i身高记为 hi (1 ≤ hi ≤ 1,000,000,000)，所有奶牛面向东方（本题示意图的右面）依次站成一条线。
// 因此，奶牛i能够看到在它前面的（奶牛i+1，i+2…）所有身高比它低的奶牛，直到被一头比它高的奶牛挡住
// 考虑如下的例子：
//         =
// =       =
// =   -   =         Cows facing right ->
// =   =   =
// = - = = =
// = = = = = =
// 1 2 3 4 5 6 
// 奶牛#1 可以看见奶牛#2, 3, 4的头顶
// 奶牛#2 无法看到任何奶牛的头顶
// 奶牛#3可以看见奶牛#4的头顶
// 奶牛#4无法看到任何奶牛的头顶
// 奶牛#5可以看见奶牛#6的头顶
// 奶牛#6无法看到任何奶牛的头顶!
// 用ci表示奶牛i能够看到头顶的奶牛个数；请计算c1 至cN的和。
// 对于上面这个例子，其和为：3 + 0 + 1 + 0 + 1 + 0 = 5。

// 时间限制：2000
// 内存限制：65536
// 输入
// 第1行：奶牛数N第2行至N+1行：第i+1行包含一个整数，表示奶牛i的高度
// 输出
// 第1行：c1 至cN的累加和
// 样例输入
// 6
// 10
// 3
// 7
// 4
// 12
// 2
// 样例输出
// 5

// 解题思路：
// 1.首先，对于每一个奶牛，我们需要知道它能看到的前面的奶牛的数量。
// 2.因此，我们可以开一个stk数组来存储奶牛的位置，从前往后遍历，
// 如果当前的奶牛比栈顶的奶牛高，那么弹出栈顶元素，直到遇到比当前奶牛低的奶牛，
// 此时这个栈顶的奶牛就是当前奶牛能看到的最左边的奶牛，
// 那么当前奶牛能看到的数量就是它的位置与栈顶的位置的差。
// 3.最后，遍历一遍c数组，把所有的c数累加即可。



#include <bits/stdc++.h>
using namespace std;

// 定义奶牛数量的最大值
const int N = 800005;

int h[N]; // 存储每头奶牛的高度
int stk[N]; // 存储递增栈
long long c[N]; // 存储每头奶牛看到的奶牛数量

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> h[i];
    }

    int tt = -1;
    // 遍历每头奶牛
    for (int i = 0; i < n; i++) {
        // 当栈顶元素高度小于等于当前奶牛高度时，弹出栈顶元素
        while (tt >= 0 && h[stk[tt]] <= h[i]) {
            tt--;
        }

        // 如果栈不为空，计算当前奶牛看到的奶牛数量
        if (tt >= 0) {
            c[i] = i - stk[tt];
        }
        // 将当前奶牛的编号入栈
        stk[++tt] = i;
    }

    long long sum = 0;
    // 统计所有奶牛看到的奶牛数量的总和
    for (int i = 0; i < n; i++) {
        sum += c[i];
    }
    cout << sum << endl;
    return 0;
}

