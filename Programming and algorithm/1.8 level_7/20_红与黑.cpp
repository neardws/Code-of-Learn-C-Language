// 红与黑
// 有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。
// 时间限制：1000
// 内存限制：65536
// 输入
// 包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。
// 输出
// 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。
// 样例输入
// 6 9 
// ....#. 
// .....# 
// ...... 
// ...... 
// ...... 
// ...... 
// ...... 
// #@...# 
// .#..#. 
// 0 0
// 样例输出
// 45

// 解题思路：
// 这道题可以使用深度优先搜索（DFS）来解决。从起始点开始进行DFS遍历，遍历到的黑色瓷砖都标记为已访问，然后递归访问相邻的黑色瓷砖，直到无法访问到新的黑色瓷砖为止。最终返回访问到的黑色瓷砖的数量。

// 具体实现时，我们可以用一个二维数组记录每个瓷砖的颜色和是否已访问过，用两个变量记录起始点的位置，然后定义一个递归的DFS函数进行搜索，每次访问到新的黑色瓷砖就标记为已访问并递归访问相邻的黑色瓷砖，最后返回访问到的黑色瓷砖数量即可。


#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 20;
char map[MAXN][MAXN]; // 保存地图的二维数组
bool vis[MAXN][MAXN]; // 标记每个瓷砖是否已经访问过
int w, h; // 地图的宽度和高度
int sx, sy; // 起始点的坐标

// 深度优先搜索函数，返回从当前位置能够到达的黑色瓷砖数量
int dfs(int x, int y) {
    if (x < 0 || x >= h || y < 0 || y >= w || map[x][y] == '#' || vis[x][y]) {
        // 当前位置越界、是白色瓷砖或者已经访问过，返回0
        return 0;
    }
    // 标记当前位置已经访问过
    vis[x][y] = true;
    // 继续递归访问相邻的黑色瓷砖，并将结果相加
    return 1 + dfs(x-1, y) + dfs(x+1, y) + dfs(x, y-1) + dfs(x, y+1);
}

int main() {
    while (cin >> w >> h && (w != 0 || h != 0)) {
        // 读入地图
        memset(vis, false, sizeof(vis));
        for (int i = 0; i < h; i++) {
            for (int j = 0; j < w; j++) {
                cin >> map[i][j];
                if (map[i][j] == '@') {
                    // 记录起始点的位置
                    sx = i;
                    sy = j;
                }
            }
        }
        // 输出结果
        cout << dfs(sx, sy) << endl;
    }
    return 0;
}
