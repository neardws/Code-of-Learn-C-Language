// 迷宫
// 一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由n * n的格点组成，每个格点只有2种状态，.和#，前者表示可以通行后者表示不能通行。同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。如果起点或者终点有一个不能通行(为#)，则看成无法办到。
// 时间限制：3000
// 内存限制：65536
// 输入
// 第1行是测试数据的组数k，后面跟着k组输入。每组测试数据的第1行是一个正整数n (1 <= n <= 100)，表示迷宫的规模是n * n的。接下来是一个n * n的矩阵，矩阵中的元素为.或者#。再接下来一行是4个整数ha, la, hb, lb，描述A处在第ha行, 第la列，B处在第hb行, 第lb列。注意到ha, la, hb, lb全部是从0开始计数的。
// 输出
// k行，每行输出对应一个输入。能办到则输出“YES”，否则输出“NO”。
// 样例输入
// 2
// 3
// .##
// ..#
// #..
// 0 0 2 2
// 5
// .....
// ###.#
// ..#..
// ###..
// ...#.
// 0 0 4 0
// 样例输出
// YES
// NO

// 解题思路：
// 题目要求我们判断从点 A 到点 B 是否可以走通。我们可以使用深度优先搜索（DFS）算法来解决。

// 首先，我们可以定义一个二维数组 maze 来表示迷宫的矩阵，其中 maze[i][j] 表示第 i 行、第 j 列的格点的状态。我们可以使用递归算法来搜索从点 A 到点 B 是否可以走通。

// 对于每个格点，我们首先判断它是否越界或者为墙（即状态为 #）。如果是，则直接返回 false。否则，我们将当前格点的状态改为墙，然后分别向上、下、左、右四个方向递归搜索。如果其中有一条路能够到达点 B，则返回 true。否则，将当前格点的状态改回可通行的状态（即 .），然后返回 false。

// 最终，我们将从点 A 到点 B 是否可以走通的结果输出即可。

// 在主函数中，我们首先读入测试数据的组数 T。然后，对于每组测试数据，我们首先读入迷宫的规模 n，然后读入迷宫矩阵和起点、终点的坐标。接着，我们调用 dfs 函数来搜索从起点是否能到达终点，并将结果输出。


#include <bits/stdc++.h>
using namespace std;

vector<vector<char>> maze;  // 定义迷宫矩阵
vector<vector<int>> dirs{{-1, 0}, {0, -1}, {1, 0}, {0, 1}};  // 定义四个方向

// 深度优先搜索函数，用于搜索从点 (x, y) 是否可以到达点 (tx, ty)
bool dfs(int x, int y, int tx, int ty) {
    if (x < 0 || x >= maze.size() || y < 0 || y >= maze[0].size() || maze[x][y] == '#') {
        return false;  // 如果越界或者为墙，则返回 false
    }
    if (x == tx && y == ty) {
        return true;  // 如果到达点 (tx, ty)，则返回 true
    }
    maze[x][y] = '#';  // 将当前格点的状态改为墙
    for (auto dir : dirs) {  // 分别向上、下、左、右四个方向搜索
        int nx = x + dir[0];
        int ny = y + dir[1];
        if (dfs(nx, ny, tx, ty)) {
            return true;  // 如果其中有一条路能够到达点 (tx, ty)，则返回 true
        }
    }
    maze[x][y] = '.';  // 将当前格点的状态改回可通行的状态
    return false;  // 如果所有路都走不通，则返回 false
}

int main() {
    int T;
    cin >> T;

    while (T--) {
        int n;
        cin >> n;

        // 读入迷宫矩阵
        maze.resize(n, vector<char>(n));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cin >> maze[i][j];
            }
        }

        int ha, la, hb, lb;
        cin >> ha >> la >> hb >> lb;

        // 判断从点 (ha, la) 是否可以到达点 (hb, lb)
        if (maze[ha][la] == '#' || maze[hb][lb] == '#' || !dfs(ha, la, hb, lb)) {
            cout << "NO" << endl;
        } else {
            cout << "YES" << endl;
        }
    }

    return 0;
}
