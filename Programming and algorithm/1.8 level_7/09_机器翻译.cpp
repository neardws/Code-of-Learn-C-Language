// 机器翻译
// 机器翻译
// VariantF的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。
// 这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。
// 对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；
// 如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。
// 假设内存中有M 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，
// 如果当前内存中已存入的单词数不超过M，软件会将新单词存入一个未使用的内存单元；若内存中已存入M 个单词，
// 软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。
// 假设一篇英语文章的长度为N 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？
// 假设在翻译开始前，内存中没有任何单词。
// 时间限制：1000
// 内存限制：262144
// 输入
// 第一行为两个正整数M 和N，代表内存容量和文章的长度。 
// 第二行为N 个非负整数，按照文章的顺序，每个数（大小不超过1000000）代表一个英文单词。
// 文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。 
// 对于50%的数据，1<=N、M<=1000； 对于100%的数据，1<=N、M<=1000000。
// 输出
// 一个整数，为软件需要查词典的次数。
// 样例输入
// 3 7 
// 1 2 1 5 4 4 1 
// 样例输出
// 5
// 提示
// 整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况: 空：内存初始状态为空。 1． 1：查找单词1 并调入内存。 2． 1 2：查找单词2 并调入内存。 3． 1 2：在内存中找到单词1。 4． 1 2 5：查找单词5 并调入内存。 5． 2 5 4：查找单词4 并调入内存替代单词1。 6． 2 5 4：在内存中找到单词4。 7． 5 4 1：查找单词1 并调入内存替代单词2。 共计查了5 次词典。


// 解题思路：

// 题目要求计算机翻译一篇英文文章需要查字典的次数。
// 翻译软件首先将单词存储在内存中，如果内存满了，那么就要从内存中清除最早进入的单词，腾出空间存储新的单词。
// 对于每个单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；
// 如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

// 因此，我们需要用一个数组来模拟内存，用一个计数器记录查找字典的次数。
// 每当软件遇到一个新单词，首先在内存中查找，如果没有找到就需要从外存中查找，并将单词和译义存入内存。
// 如果内存已满，就需要从内存中清除最早进入的单词，腾出空间存储新的单词。
// 在模拟过程中需要使用一些技巧来减少时间和空间的使用。

// 具体的模拟过程如下：

// 读入内存大小 M 和文章长度 N，初始化一个大小为 M 的数组 word，用于模拟内存，将数组中的所有元素初始化为 -1。
// 读入文章，对于每个单词，首先在内存中查找。如果内存中没有这个单词，就需要从外存中查找，并将单词和译义存入内存。
// 如果内存已满，就需要从内存中清除最早进入的单词，腾出空间存储新的单词，并将新单词存入内存。
// 统计查找字典的次数，输出结果。
// 需要注意的是，在模拟过程中需要使用一个计数器 tm 记录当前存储在内存中的单词个数，当内存已满时，需要将计数器归零。
// 为了避免遍历内存数组的时间复杂度为 $O(M)$，可以使用一个简单的线性搜索算法，因为单词数目不会超过 M。

#include <bits/stdc++.h>

int word[1000000]; // 定义一个数组 word 来模拟内存
// 这里可以将数组长度设置为题目所给的最大内存值 1000000

bool sch(int tgt, int range) { // 线性搜索，用于在内存中查找单词
    for (int i = 0; i < range; i++) {
        if (word[i] == tgt) {
            return true;
        }
    }
    return false;
}

int main() {
    int mem, num, tm = 0, ans = 0;
    // mem 表示内存大小，num 表示文章长度
    // tm 用于记录当前存储在内存中的单词个数
    // ans 用于记录查找字典的次数
    scanf("%d %d", &mem, &num);

    for (int i = 0; i < 1000000; i++) {
        word[i] = -1; // 初始化数组，将每个元素的值设置为 -1
    }

    for (int i = 0; i < num; i++) {
        int wor;
        scanf("%d", &wor);

        if (!sch(wor, mem)) { // 如果内存中没有这个单词
            ans++; // 需要查找字典
            if (tm >= mem) { // 如果内存已满
                tm = 0; // 将计数器归零
            }
            word[tm] = wor; // 存储新单词
            tm++; // 计数器加 1
        }
    }

    printf("%d", ans); // 输出查找字典的次数
    return 0;
}
