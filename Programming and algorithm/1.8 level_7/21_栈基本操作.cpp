// 栈基本操作
// 依次读入序列元素1,2,...,n进栈，每进一个元素，机器可要求下一个元素进栈或弹栈，
// 如此进行。给定一个输入序列，判断栈空时弹出的元素构成的序列是否可能等于给定的序列，
// 如果是则输出栈的操作过程，否则输出“NO”。
// 时间限制：1000
// 内存限制：65535
// 输入
// 输入分两行 第一行为n的值（即序列元素个数） 第二行为给定的输入序列（序列元素均为整型）
// 输出
// 如果输入序列能够由题目规定的操作得到，则输出对栈的操作过程 否则直接输出“NO”
// 样例输入
// 7
// 4 5 3 6 2 7 1
// 样例输出
// PUSH 1
// PUSH 2
// PUSH 3
// PUSH 4
// POP 4
// PUSH 5
// POP 5
// POP 3
// PUSH 6
// POP 6
// POP 2
// PUSH 7
// POP 7
// POP 1
// 提示
// 给定序列中有可能有不在1...n之间的数字

// 解题思路：

// 1. 读入序列的元素个数n；
// 2. 建立一个栈s，并依次读入序列元素；
// 3. 对于每个元素，如果栈顶元素等于该元素，则弹出栈顶元素；
// 4. 如果栈为空，则说明该序列是合法的，输出操作过程；否则说明该序列是不合法的，输出"NO"。

#include<bits/stdc++.h>
using namespace std;
const int N=10010; // 定义数组长度
int a[N]; // 定义数组a存储输入的序列
stack<int>s; // 定义栈s
int main()
{
    int n;
    cin>>n; // 读入序列元素个数
    for(int i=0;i<n;i++)
    {
        cin>>a[i]; // 读入序列元素
    }
    int now=0; // 初始化当前序列元素的下标
    for(int i=1;i<=n;i++)
    {
        s.push(i); // 将i压入栈
        cout<<"PUSH "<<i<<endl; // 输出操作过程
        while(!s.empty()&&s.top()==a[now]) // 如果栈顶元素等于当前序列元素
        {
            s.pop(); // 弹出栈顶元素
            cout<<"POP "<<a[now]<<endl; // 输出操作过程
            now++; // 当前序列元素的下标加1
        }
    }
    if(s.empty()) // 如果栈为空
    {
        return 0; // 直接结束程序
    }
    else // 否则
    {
        cout<<"NO"<<endl; // 输出"NO"
    }
    return 0;
}
