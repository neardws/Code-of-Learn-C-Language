// priority queue练习题
// 我们定义一个正整数a比正整数b优先的含义是：
// a的质因数数目（不包括自身）比b的质因数数目多；
// 当两者质因数数目相等时，数值较大者优先级高。
// 现在给定一个容器，初始元素数目为0，之后每次往里面添加10个元素，
// 每次添加之后，要求输出优先级最高与最低的元素，并把该两元素从容器中删除。
// 时间限制：2500
// 内存限制：131072
// 输入
// 第一行: num (添加元素次数，num <= 30)
// 下面10*num行，每行一个正整数n（n < 10000000).
// 输出
// 每次输入10个整数后，输出容器中优先级最高与最低的元素，两者用空格间隔。
// 样例输入
// 1
// 10 7 66 4 5 30 91 100 8 9
// 样例输出
// 66 5

// 解题思路：
// 这道题可以使用优先队列（priority_queue）来实现。
// 我们可以定义一个结构体 Num 来表示每个数字，其中包含数字本身 num，以及它的质因数个数 cnt。
// 我们可以自定义一个比较函数，使得 Num 类型的对象可以通过质因数个数和数值大小来比较大小。

// 每次往容器中添加 10 个元素后，我们可以将它们放入一个优先队列中，然后取出队首和队尾的元素，
// 即优先级最高和最低的元素。由于我们需要将这两个元素从容器中删除，因此可以将这两个元素弹出优先队列，
// 然后将剩余的元素重新放入优先队列中。

// 在主函数中，我们首先读入添加元素的次数 n，然后对于每一次添加，我们读入 10 个整数，
// 依次计算它们的质因数个数，并将数字和质因数个数插入优先队列中。然后，我们输出优先级最高和最低的元素，
// 并将它们从优先队列中弹出。最后，我们将剩余的元素从优先队列中弹出即可。

#include <bits/stdc++.h>
using namespace std;

struct Num {
    int num;  // 数字本身
    int cnt;  // 质因数个数（不包括自身）

    // 自定义比较函数
    bool operator < (const Num& other) const {
        if (cnt != other.cnt) {
            return cnt < other.cnt;
        }
        return num < other.num;
    }
};

// 计算一个数的质因数个数
int getPrimeCount(int x) {
    int count = 0;
    for (int i = 2; i <= sqrt(x); i++) {
        while (x % i == 0) {
            count++;
            x /= i;
        }
    }
    if (x > 1) {
        count++;
    }
    return count;
}

int main() {
    int n;
    cin >> n;

    while (n--) {
        priority_queue<Num> q;  // 定义一个优先队列
        for (int i = 0; i < 10; i++) {
            int num;
            cin >> num;
            q.push({num, getPrimeCount(num) - 1});  // 将数字和质因数个数插入优先队列中
        }
        cout << q.top().num << " ";  // 输出优先级最高的元素
        q.pop();  // 弹出优先级最高的元素
        cout << q.top().num << endl;  // 输出优先级最低的元素
        q.pop();  // 弹出优先级最低的元素
        while (!q.empty()) {
            q.pop();  // 弹出剩余的元素
        }
    }

    return 0;
}
