// 拨钟问题
// 有9个时钟，排成一个3*3的矩阵。
// |-------|    |-------|    |-------|
// |       |    |       |    |   |   |
// |---O   |    |---O   |    |   O   |
// |       |    |       |    |       |
// |-------|    |-------|    |-------|
//     A            B            C    

// |-------|    |-------|    |-------|
// |       |    |       |    |       |
// |   O   |    |   O   |    |   O   |
// |   |   |    |   |   |    |   |   |
// |-------|    |-------|    |-------|
//     D            E            F    

// |-------|    |-------|    |-------|
// |       |    |       |    |       |
// |   O   |    |   O---|    |   O   |
// |   |   |    |       |    |   |   |
// |-------|    |-------|    |-------|
//     G            H            I    
// (图 1)
// 现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。
// 共允许有9种不同的移动。
// 如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。

// 移动    影响的时钟

//  1         ABDE
//  2         ABC
//  3         BCEF
//  4         ADG
//  5         BDEFH
//  6         CFI
//  7         DEGH
//  8         GHI
//  9         EFHI    
// 时间限制：1000
// 内存限制：65536
// 输入
// 9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0=12点、1=3点、2=6点、3=9点。
// 输出
// 输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。相邻两个整数之间用单个空格隔开。
// 样例输入
// 3 3 0 
// 2 2 2 
// 2 1 2 
// 样例输出
// 4 5 8 9 


// 主要思想就是利用一次线性约束关系，降低循环重数，
// 就像x+y+z=0一样，知道其中两个就能唯一确定第三个，
// 对于本题，首先通过任意一次操作进行4次就回到原来的状态，
// 故每个操作至多进行3次，经过观察，本题可以通过三种循环得到前三个操作的操作次数，
// 然后利用约束关系求出剩下6个操作的次数，
// 将9个求得的操作次数用剩余的几个时钟来验证是否满足题目要求，
// 在满足的情况下找到进行比较保留最小步骤数的一组即可。
// (要注意的是，其中的约束关系可以是任意一组，再用剩余的验证即可）


#include<bits/stdc++.h>
using namespace std;
//0,1,2,3,4,5,6,7,8
//A,B,C,D,E,F,G,H,I
int clocks[9] = { 0 };

int steps[9] = { 0 };//每种操作对应的操作次数

//利用约束关系求出其余操作所需最小次数
void check_road(int i1, int i2, int i3) {
	int i4 = (4 - ((i1 + i2 + clocks[0]) % 4)) % 4;//A
	int i5 = (4 - ((i1 + i2 + i3 + clocks[1]) % 4)) % 4;//B
	int i6 = (4 - ((i2 + i3 + clocks[2]) % 4)) % 4;//C
	int i7 = (4 - ((i1 + i4 + i5 + clocks[3]) % 4)) % 4;//D
	int i9 = (4 - ((i1 + i3 + i5 + i7 + clocks[4]) % 4)) % 4;//E
	int i8 = (4 - ((i6 + i9 + clocks[8]) % 4)) % 4;//I
	//F,G,H
	if (//满足题目要求，全为12点
		(clocks[5] + i3 + i5 + i6 + i9) % 4 == 0 &&//F
		(clocks[6] + i4 + i7 + i8) % 4 == 0 &&//G
		(clocks[7] + i5 + i7 + i8 + i9) % 4 == 0//H
		) {

		int tmp[9] = { i1,i2,i3,i4,i5,i6,i7,i8,i9 };
		int sum = 0, ans = 0;
		for (int i = 0; i < 9; ++i)
			sum += tmp[i], ans += steps[i];

		if (sum < ans)//取总的路径数最小的
			memcpy(steps, tmp, sizeof(steps));
	}
}

//i1,i2,i3
void find() {
	for (int i = 0; i < 4; ++i) {
		for (int j = 0; j < 4; ++j) {
			for (int k = 0; k < 4; ++k) {
				check_road(i, j, k);
			}
		}
	}
}

int main() {
	for (int i = 0; i < 9; ++i)
		cin >> clocks[i], steps[i] = 4;//初始化为一个比4大的

	find();

	for (int i = 0; i < 9; ++i)
		while(steps[i]--)//按顺序依次输出步数大于0的步骤
			cout << i + 1 << ' ';

	return 0;
}

