// 4982:踩方格
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设：
// a.    每走一步时，只能从当前方格移动一格，走到某个相邻的方格上；
// b.    走过的格子立即塌陷无法再走第二次；
// c.    只能向北、东、西三个方向走；
// 请问：如果允许在方格矩阵上走n步，共有多少种不同的方案。
// 2种走法只要有一步不一样，即被认为是不同的方案。

// 输入
// 允许在方格上行走的步数n(n <= 20)
// 输出
// 计算出的方案数量
// 样例输入
// 2
// 样例输出
// 7
// http://noi.openjudge.cn/ch0206/4982/

// 题解：

// 只能朝着北、东、西三个方向即为上、左、右，不能向下。而向左（右）走之后前面格子塌陷，无法往回走，只能向上、右（左）走这两种情况，但是向上走之后可以继续向上或向左、向右走，有三种情况。对于N步的所有走法，可以从最后一步出发将他们分为两种状态，第一种的最后一步是从下面走上来的，第二种的最后一步是从右边或是左边走过来的。这两种的区别就在于，第一种可以衍生出三种走法，第二种只能衍生出两种走法。对于N+1步的所有走法来说，它的所有走法便是从N步的所有走法衍生而来的，所以只要找到N步所有走法中第一种走法的个数与与第二种走法的个数便可以计算出N+1步所有走法的个数。而N步第一种走法，便是N-1步所有走法向上走一步衍生而来的，所以N步第一种走法个数等同于N-1步所有走法的个数。而N步第二种走法个数即为走法总数减去第一种走法个数。而N+1步走法总数即为N步第一种走法个数3+i步第二种走法2。设f[i]为走i步走法总数，即可得出f[i]=(f[i-1]-f[i-2])*2+f[i-2]*3,化简一下，可得f[i]=f[i-1]*2+f[i-2]。千万不要忘记设置初始值f[0]=1(原地不动也是一种走法)，f[1]=3。

// 解法： f[i]表示走 i 格的方案数。

// 状态转移方程推导如下——
// 设l[i],r[i],u[i]分别为第 i 步向西、东、北的方案数，
// f[i]为总方案数。
// l[i]=l[i-1]+u[i-1]
// r[i]=r[i-1]+u[i-1] 
// u[i]=l[i-1]+r[i-1]+u[i-1]
// f[i]=l[i]+r[i]+u[i]
// =2*l[i-1]+2*r[i-1]+3*u[i-1]
// =2*f[i-1]+u[i-1]
// =2*f[i-1]+f[i-2]

// 解题感受：

// 这道题的规律一定要耐心找，对，就是这样，只要找到规律就很简单了。

#include<bits/stdc++.h>
using namespace std;
int f[20];

int main(){
    int n;
    cin>>n;
    f[1]=3, f[2]=7;
    for (int i=3;i<=n;i++)
        f[i]=2*f[i-1]+f[i-2];
    cout<<f[n]<<endl;
    return 0;
}

