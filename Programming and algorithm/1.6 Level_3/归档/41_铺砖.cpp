// 9273:PKU2506Tiling(铺砖)
// 总时间限制: 2000ms 单个测试点时间限制: 1000ms 内存限制: 131072kB
// 描述
// 对于一个2行N列的走道。现在用1*2,2*2的砖去铺满。问有多少种不同的方式。

// 输入
// 整个测试有多组数据，请做到文件底结束。每行给出一个数字N，0 <= n <= 250

// 输出
// 如题

// 样例输入
// 2
// 8
// 12
// 100
// 200
// 样例输出
// 3
// 171
// 2731
// 845100400152152934331135470251
// 1071292029505993517027974728227441735014801995855195223534251 注意一下这个数字，它是一个很大的数

// 找出递推关系式即可：
// 最后一块1*2横放： f(n)=f(n-2)   
// 最后一块1*2竖放： f(n)=f(n-1) 
// 最后一块2*2 ： f(n)=f(n-2)
// 故f(n)=f(n-1)+2*f(n-2);
// 边界条件 f(1)=1；f(2)=3 

#include <bits/stdc++.h>
using namespace std;
int a[300][1000];
int main(){
    a[1][0]=1, a[1][1]=1;  //a[i][0]表示第i位的长度
    a[2][0]=1, a[2][1]=3;
    for(int i = 3; i <= 250; i++){      //使用递推式进行计算       
        for(int j = 1; j <= max(a[i-1][0],a[i-2][0]); j++)     // 每一位上进行计算
            a[i][j] = a[i-1][j] + a[i-2][j] * 2;
        a[i][0]=max(a[i-1][0],a[i-2][0]);
        for(int j=1; j<=a[i][0]; j++)
            if(a[i][j]>=10){         //如果数字大于10，则需要进行进位   
                a[i][j+1] += a[i][j] / 10;
                a[i][j] %= 10;
            }
        if(a[i][a[i][0]+1])     //如果最后一位进位了，则长度加1
            a[i][0]++;
    }
    int n;
    while(cin>>n){
        if(n==0)
            cout<<"1"<<endl;
        else{
            for(int i=a[n][0];i>=1;i--)
                cout<<a[n][i];
            cout<<endl;
        }
    }
    return 0;
}

