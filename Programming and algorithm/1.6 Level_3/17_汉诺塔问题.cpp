// 6261:汉诺塔问题
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，
// 最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。
// 目的是将最左边杆上的盘全部移到中间的杆上，
// 条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。 
// 这是一个著名的问题，几乎所有的教材上都有这个问题。
// 由于条件是一次只能移动一个盘，且不允许大盘放在小盘上面，
// 所以64个盘的移动次数是：18,446,744,073,709,551,615
// 这是一个天文数字，若每一微秒可能计算(并不输出)一次移动，
// 那么也需要几乎一百万年。
// 我们仅能找出问题的解决方法并解决较小N值时的汉诺塔，
// 但很难用计算机解决64层的汉诺塔。 
// 假定圆盘从小到大编号为1, 2, ...

// 输入
// 输入为一个整数后面跟三个单字符字符串。
// 整数为盘子的数目，后三个字符表示三个杆子的编号。
// 输出
// 输出每一步移动盘子的记录。一次移动一行。
// 每次移动的记录为例如 a->3->b 的形式，
// 即把编号为3的盘子从a杆移至b杆。
// 样例输入
// 2 a b c
// 样例输出
// a->1->c
// a->2->b
// c->1->b
// http://noi.openjudge.cn/ch0202/6261/

#include<bits/stdc++.h>
using namespace std;
//这个题给出的结果就是按照步骤来的，先从a->c，再a->b,最后c->b 
void f(int n, char a, char b, char c){  //从a移动到b，c是辅助的 
    if(n==0)
        return;
    if(n==1)
        cout<<a<<"->"<<n<<"->"<<b<<endl;
    else{
        f(n-1,a,c,b);//将n-1个盘子从a移动到c,b是辅助的
        cout<<a<<"->"<<n<<"->"<<b<<endl;//然后将第n个柱子 由a 移到 b即可
        f(n-1,c,b,a);//剩下的 再将n-1个盘子 由c移到b 其中a为辅助柱子  
    }
}
int main(){
    int n;
    char a,b,c;
    cin>>n>>a>>b>>c;
    f(n,a,b,c);
}