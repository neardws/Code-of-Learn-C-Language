// 1797:金银岛
// http://noi.openjudge.cn/ch0406/1797/
// 总时间限制: 3000ms 内存限制: 65536kB
// 描述
// 某天KID利用飞行器飞到了一个金银岛上，上面有许多珍贵的金属，KID虽然更喜欢各种宝石的艺术品，可是也不拒绝这样珍贵的金属。
// 但是他只带着一个口袋，口袋至多只能装重量为w的物品。
// 岛上金属有s个种类, 每种金属重量不同，分别为n1, n2, ... , ns，同时每个种类的金属总的价值也不同，分别为v1,v2, ..., vs。
// KID想一次带走价值尽可能多的金属，问他最多能带走价值多少的金属。
// 注意到金属是可以被任意分割的，并且金属的价值和其重量成正比。
// 输入
// 第1行是测试数据的组数k，后面跟着k组输入。
// 每组测试数据占3行，第1行是一个正整数w (1 <= w <= 10000)，表示口袋承重上限。
// 第2行是一个正整数s (1 <= s <=100)，表示金属种类。
// 第3行有2s个正整数，分别为n1, v1, n2, v2, ... , ns, vs分别为第一种，第二种，...，
// 第s种金属的总重量和总价值(1 <= ni <= 10000, 1 <= vi <= 10000)。
// 输出
// k行，每行输出对应一个输入。输出应精确到小数点后2位。
// 样例输入
// 2
// 50
// 4
// 10 100 50 30 7 34 87 100
// 10000
// 5
// 1 43 43 323 35 45 43 54 87 43
// 样例输出
// 171.93
// 508.00

#include<bits/stdc++.h>
using namespace std;
struct node{ 	//node：自定义结构体类型名 
	int z, j;	//定义结构体成员z（重量）和j（总价值） 
	double d;	//定义结构体成员d（单价） 
}a[105];	//数组名 
bool cmp(node a, node b){	//自定义排序方法 
	return a.d	> b.d;	//按倒序排序 
}
int main(){
	int i, s, w, n; // i 用来循环，w 表示口袋承重上限，s 表示岛上的金属种类 
	double ans; 	// ans表示能带走的矿物总价值 
	cin >> n;	 //  输入n（组数） 
	while(n--){  //	 循环n次 
		ans = 0;	// ans初始化 
		cin>>w>>s;	// 输入承重上限和金属种类 
		for(i=1; i <= s; i++){	//循环s次 
			cin>>a[i].z>>a[i].j;	//输入金属重量和金属价格 
			a[i].d = a[i].j * 1.0 / a[i].z;	//计算金属单价 
		}
		sort(a + 1, a + 1 + s, cmp);//按金属单价倒序排序 
		for(i = 1; i <= s; i++){	//循环s次 
			if(w >= a[i].z){ 	//如果口袋能装下该种金属 
				ans += a[i].j;	//总价值增加 
				w -= a[i].z;	//口袋容量减小 
			}
			else{  //如果装不下 
				ans += w * a[i].d;	//能装多少装多少 
				w = 0;
				break;	//提高效率 
			}
		}
		printf("%.2lf\n",ans);//输出矿物价值
	}
    return 0;
}
