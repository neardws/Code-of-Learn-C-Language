// 2727:仙岛求药
// http://noi.openjudge.cn/ch0205/2727/
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 少年李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。
// 叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，发现仙药摆在了迷阵的深处。
// 迷阵由M×N个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。
// 现在李逍遥想尽快找到仙药，显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。现在要求你来帮助他实现这个目标。
// 下图 显示了一个迷阵的样例及李逍遥找到仙药的路线.

// 输入
// 输入有多组测试数据. 每组测试数据以两个非零整数 M 和 N 开始，两者均不大于20。
// M 表示迷阵行数, N 表示迷阵列数。接下来有 M 行, 每行包含N个字符,不同字符分别代表不同含义: 
// 1) ‘@’：少年李逍遥所在的位置；
// 2) ‘.’：可以安全通行的方格；
// 3) ‘#’：有怪物的方格；
// 4) ‘*’：仙药所在位置。
// 当在一行中读入的是两个零时，表示输入结束。
// 输出
// 对于每组测试数据，分别输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目(计数包括初始位置的方块)。如果他不可能找到仙药, 则输出 -1。
// 样例输入
// 8 8
// .@##...#
// #....#.#
// #.#.##..
// ..#.###.
// #.#...#.
// ..###.#.
// ...#.*..
// .#...###
// 6 5
// .*.#.
// .#...
// ..##.
// .....
// .#...
// ....@
// 9 6
// .#..#. 
// .#.*.# 
// .####. 
// ..#... 
// ..#... 
// ..#... 
// ..#... 
// #.@.## 
// .#..#. 
// 0 0
// 样例输出
// 10
// 8
// -1

#include<bits/stdc++.h>
using namespace std;
struct Node
{
	int x, y, s;//从起点走到(x,y)位置时已经走了s步 
	Node(){
    }
	Node(int a, int b, int c):x(a), y(b), s(c) {
    }
};
int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};//方向数组 
char mp[25][25];//地图 
bool vis[25][25];//vis[i][j]:(i,j)位置是否已访问 
int m, n, sx, sy;//(sx, sy)：起点 
int bfs()//广搜求从起点到终点的最短距离 
{
    
	queue<Node> que;
	vis[sx][sy] = true;
	que.push(Node(sx, sy, 0));//起点入队，在起点时步数为0 
	while(que.empty() == false)
	{
    
		Node u = que.front();
		que.pop();
		if(mp[u.x][u.y] == '*')//如果该位置是终点 
			return u.s;//输出到终点时的步数 
		for(int i = 0; i < 4; ++i)
		{
    
			int x = u.x + dir[i][0], y = u.y + dir[i][1], s = u.s + 1; 
			if(x >= 1 && x <= m && y >= 1 && y <= n && mp[x][y] != '#' && vis[x][y] == false) 
			{   //如果(x,y)在地图内，不是墙，没访问过 
				vis[x][y] = true;//访问该位置 
				que.push(Node(x, y, s));//到(x,y)时步数为s，入队 
			}
		}
	}
	return -1;//如果无法到达终点，则会运行到这里，返回-1 
}
int main()
{   
	while(cin >> m >> n)
	{
        if(m == 0 && n == 0)
            break;
		for(int i = 1; i <= m; ++i)
			for(int j = 1; j <= n; ++j)
			{
    
				cin >> mp[i][j];
				if(mp[i][j] == '@')
					sx = i, sy = j; 
			}
		memset(vis, 0, sizeof(vis));//多组数据，注意数据清零 
		cout << bfs() << endl;
	} 
	return 0; 
}