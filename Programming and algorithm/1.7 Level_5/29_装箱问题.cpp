// 19:装箱问题
// http://noi.openjudge.cn/ch0406/19/
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 一个工厂制造的产品形状都是长方体，它们的高度都是h，长和宽都相等，
// 一共有六个型号，他们的长宽分别为1*1, 2*2, 3*3, 4*4, 5*5, 6*6。
// 这些产品通常使用一个 6*6*h 的长方体包裹包装然后邮寄给客户。
// 因为邮费很贵，所以工厂要想方设法的减小每个订单运送时的包裹数量。
// 他们很需要有一个好的程序帮他们解决这个问题从而节省费用。现在这个程序由你来设计。
// 输入
// 输入文件包括几行，每一行代表一个订单。每个订单里的一行包括六个整数，中间用空格隔开，分别为1*1至6*6这六种产品的数量。
// 输入文件将以6个0组成的一行结尾。
// 输出
// 除了输入的最后一行6个0以外，输入文件里每一行对应着输出文件的一行，每一行输出一个整数代表对应的订单所需的最小包裹数。
// 样例输入
// 0 0 4 0 0 1 
// 7 5 1 0 0 0 
// 0 0 0 0 0 0 
// 样例输出
// 2 
// 1 
// 来源
// Central Europe 1996

// 这题的思路很明了,无非是更多地利用空间,尽可能少地空出空位。 

// 不妨设 1*1、2*2、3*3、4*4、5*5、6*6的长方体数量分别为 a, b, c, d, e, f
// 记当前答案为ans,我们知道 6*6、5*5、4*4的长方体由于体积太大,一箱只能放一个,故ans至少是。 
// 当一个箱子放了一个 6*6 的长方体时, 刚好被装满； 
// 当一个箱子放了一个 5*5 的长方体时, 余下11个 1*1 的格子； 
// 当一个箱子放了一个 4*4 的长方体是, 余下9个 2*2 的格子； 
// 接下来讨论放 3*3 的长方体, 我们知道四个 3*3 的长方体能刚好放满一个箱子, 
// 剩下 3*3 的长方体再放入另一个箱子, 于是ans要加上。 
// 当一个箱子放了一个 3*3 的长方体后, 余下5个 2*2 的格子和7个 1*1 的格子； 
// 当一个箱子放了两个 3*3 的长方体后, 余下3个 2*2 的格子和6个 1*1 的格子； 
// 当一个箱子放了三个 3*3 的长方体后, 余下1个 2*2 的格子和5个 1*1 的格子； 


#include<bits/stdc++.h>
using namespace std;
const int N = 6;    

int a[N];   // 存储每种产品的数量

void init() {
    memset(a, 0, sizeof(a));    // 将a数组清零
}

int numofboxes() {
    int box = 0;    //一共要装产品的盒子的个数;
    box += a[5];    //6*6*h的产品每个都需要装满一个盒子;
    box += a[4];    //5*5*h的产品, 每个产品装一个盒子, 之后会产生11个空格, 但空格仅满足放1*1*h的产品;
    a[0] = max(0, a[0] - a[4] * 11);    
    //1*1*h的产品可能不够, 也可能有剩余, 剩余的话则之前装5*5*h的盒子都已经填满;//之后a[0]表示剩余的1*1*h的产品数;
    box += a[3];    //填充4*4*h的产品;
    if (a[1] >= a[3] * 5) { //一个4*4*h的产品装入后还剩5个2*2*h的空间; 
        //a[3] * 5表明一共有含有4*4*h的盒子的数目中的空余格子, 每个盒子都可以最多装5个2*2*h的产品;
        a[1] -= a[3] * 5;   //填充2*2*h的产品;  
    }
    else {//2*2*h的产品不够;
        a[0] = max(0, a[0] - 4 * (a[3] * 5 - a[1]));    //再用1*1*h的产品填充本应放2*2*h的产品的空间;
        a[1] = 0;   //一个2*2空间可放4个1*1*h的产品;
    }
    box += (a[2] + 3) / 4;  //每4个3*3*h的产品独占一个盒子;//此时一个产品不足以单独占一个盒子;
    a[2] = a[2] % 4;//余下的3*3*h的产品数;
    if (a[2]) {     //有剩余的3*3*h的产品;
        if (a[1] >= 7 - 2 * a[2]) { //2*2*h的产品还有剩余;
        //1个盒子内可放1个3*3*h的产品加5个2*2*h的产品加7个1*1*h的产品;
        //1个盒子内可放2个3*3*h的产品加3个2*2*h的产品加6个1*1*h的产品； 
        //1个盒子内可放3个3*3*h的产品加1个2*2*h的产品加5个1*1*h的产品； 
            a[1] = a[1] - (7 - 2 * a[2]);
            a[0] = max(0, a[0] - (8 - a[2]));
        }   
        else {//2*2*h的产品没有剩余;
            a[0] = max(0, a[0] - (36 - 9 * a[2] - 4 * a[1]));
            //一个盒子中除去3*3*h的产品和2*2*h的产品的位置, 剩下的位置就是装1*1*h的产品的位置;
            a[1] = 0;
        }
    }
    box += ((a[1] + 8) / 9);    //如果还有剩余的2*2*h的产品, 则添加;
    //一个盒子最多可以装9个2*2*h的产品;
    a[1] = a[1] % 9;    //剩余的2*2*h的产品数目;
    if (a[1]) {     //如果还有剩余的2*2*h的产品;
        a[0] = max(0, a[0] - (36 - 4 * a[1]));//一个2*2*h的产品可占4个格子;
    }
    box += (a[0] + 35) / 36;    //一个盒子最多可以放36个1*1*h的产品;
    return box;
}

int main() {
    while (cin >> a[0] >> a[1] >> a[2] >> a[3] >> a[4] >> a[5]) {
        if (a[0] == 0 && a[1] == 0 && a[2] == 0 && a[3] == 0 && a[4] == 0 && a[5] == 0) {
            break;  // 输入全为0，结束
        }
        int ans = numofboxes();
        cout << ans << endl;    
    }
    return 0;
}