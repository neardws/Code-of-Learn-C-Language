// 1756:八皇后
// http://noi.openjudge.cn/ch0205/1756/
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。 
// 对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。
// 给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。
// 输入
// 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数b(1 <= b <= 92)
// 输出
// 输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。
// 样例输入
// 2
// 1
// 92
// 样例输出
// 15863724
// 84136275

#include<bits/stdc++.h>
using namespace std;
int col[10],L_diagonal[10],R_diagonal[10]; //分别表示标记数组，列数组，主对角线数组，副对角线数组 
int ans[10]; //结果数组
int sum; //二维数组中用来记答案种数的
int show[100][100];  //二维数组， 因为答案是92个 ，所以设置100个足够了 
void add() //累加函数，把符合条件的答案放到二维数组中 
{
    sum++; //
    for(int i=1;i<=8;i++)
        show[sum][i]=ans[i]; //把当前列的摆放放到二维数组中 
} 
void dfs(int i)//用i来表示皇后所处的行位置 
{
    int j; //用j表示皇后所处的列位置
    for(j=1;j<=8;j++)
        if((col[j]==0)&&(L_diagonal[i-j+7]==0)&& (R_diagonal[i+j]==0))// 列、主对角线、副对角线没有被占领过 
        {
            ans[i]=j; //在当前(i,j)位置上摆放一个皇后
            col[j]=1; //占领当前(i,j)所在的列
            L_diagonal[i-j+7]=1; //占领当前(i,j)所在的主对角线
            R_diagonal[i+j]=1;  //占领当前(i,j)所在的副对角线
            if(i==8)
            {
                add(); //函数进行答案整合。 
            }
            else
                dfs(i+1);
            col[j]=0; //回溯(i,j)所在的列
            L_diagonal[i-j+7]=0; //回溯当前(i,j)所在的主对角线
            R_diagonal[i+j]=0;//回溯当前(i,j)所在的副对角线    
        } 
}
int main()
{
    int n;// 定义n个数 
    cin>>n; 
    dfs(1);  //开始深搜，先把结果都保存
    while(n)
    {
        n--;
        int x;
        cin>>x;
        for(int i=1;i<=8;i++)
            cout<<show[x][i];  //输出对应数据
        cout<<endl;
    }
    
    return 0; 
}