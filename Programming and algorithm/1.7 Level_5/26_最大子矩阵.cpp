// 1768:最大子矩阵
// http://noi.openjudge.cn/ch0406/1768/
// 总时间限制: 1000ms 内存限制: 65536kB
// 描述
// 已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。

// 比如，如下4 * 4的矩阵

// 0 -2 -7 0
// 9 2 -6 2
// -4 1 -4 1
// -1 8 0 -2

// 的最大子矩阵是

// 9 2
// -4 1
// -1 8

// 这个子矩阵的大小是15。
// 输入
// 输入是一个N * N的矩阵。输入的第一行给出N (0 < N <= 100)。
// 再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）
// 给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。
// 输出
// 输出最大子矩阵的大小。
// 样例输入
// 4
// 0 -2 -7 0 9 2 -6 2
// -4 1 -4  1 -1

// 8  0 -2
// 样例输出
// 15
// 来源
// 翻译自 Greater New York 2001 的试题

#include<bits/stdc++.h>
using namespace std;
//首先是要想到把同一列看做一个数，然后对一行数据求最大连续和 
int n, a[110][110], b[110];
int dp[110], res = 0; // res 表示 最大的矩阵和
void f(int x, int y){
    for(int i = 1; i <= n; i++){   // 列数
        b[i] = 0;  // b[i] 表示 当前这列的和
        dp[i] = 0;  // dp[i] 表示 加到第 i 列的矩阵和
        for(int e = x; e <= y; e++){
            //把从第x行到第y行的第i列是数看做一个数
            b[i] += a[e][i];   
        } 
        dp[i] = b[i]; //初始化 
        if(dp[i-1] > 0){
            dp[i] = max(dp[i], dp[i-1] + b[i]);
        }
        res = max(res, dp[i]);
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = i; j <= n; j++){
            //把同一列的看做是一个数 
            f(i, j);    
        }
    }
    cout<<res<<endl;
    return 0;
}